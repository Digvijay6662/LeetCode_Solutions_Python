2338. Count the Number of Ideal Arrays
Solved
Hard
Topics
Companies
Hint
You are given two integers n and maxValue, which are used to describe an ideal array.

A 0-indexed integer array arr of length n is considered ideal if the following conditions hold:

Every arr[i] is a value from 1 to maxValue, for 0 <= i < n.
Every arr[i] is divisible by arr[i - 1], for 0 < i < n.
Return the number of distinct ideal arrays of length n. Since the answer may be very large, return it modulo 109 + 7.

 

Example 1:

Input: n = 2, maxValue = 5
Output: 10
Explanation: The following are the possible ideal arrays:
- Arrays starting with the value 1 (5 arrays): [1,1], [1,2], [1,3], [1,4], [1,5]
- Arrays starting with the value 2 (2 arrays): [2,2], [2,4]
- Arrays starting with the value 3 (1 array): [3,3]
- Arrays starting with the value 4 (1 array): [4,4]
- Arrays starting with the value 5 (1 array): [5,5]
There are a total of 5 + 2 + 1 + 1 + 1 = 10 distinct ideal arrays.
Example 2:

Input: n = 5, maxValue = 3
Output: 11
Explanation: The following are the possible ideal arrays:
- Arrays starting with the value 1 (9 arrays): 
   - With no other distinct values (1 array): [1,1,1,1,1] 
   - With 2nd distinct value 2 (4 arrays): [1,1,1,1,2], [1,1,1,2,2], [1,1,2,2,2], [1,2,2,2,2]
   - With 2nd distinct value 3 (4 arrays): [1,1,1,1,3], [1,1,1,3,3], [1,1,3,3,3], [1,3,3,3,3]
- Arrays starting with the value 2 (1 array): [2,2,2,2,2]
- Arrays starting with the value 3 (1 array): [3,3,3,3,3]
There are a total of 9 + 1 + 1 = 11 distinct ideal arrays.
 

Constraints:

2 <= n <= 104
1 <= maxValue <= 104


Solution 1:

class Solution:
    def idealArrays(self, n: int, maxValue: int) -> int:
        mod = 10**9 + 7
        
        # Compute maximum chain length: for a strictly increasing chain, 
        # each new term is at least double the previous one.
        Lmax = int(math.floor(math.log(maxValue, 2))) + 1
        # The chain length cannot exceed n (the array length)
        Lmax = min(Lmax, n)

        # Build DP table: dp[l][x] = number of divisor chains of length l ending at x.
        dp = [[0] * (maxValue + 1) for _ in range(Lmax + 1)]
        # Base case: chains of length 1 (a single element)
        for x in range(1, maxValue + 1):
            dp[1][x] = 1

        # For chain length l from 2 to Lmax, update via multiples
        for l in range(2, Lmax + 1):
            for x in range(1, maxValue + 1):
                if dp[l-1][x]:
                    for multiple in range(2 * x, maxValue + 1, x):
                        dp[l][multiple] = (dp[l][multiple] + dp[l-1][x]) % mod

        # Helper function to compute combination C(n, r) mod mod.
        # Since r is small (at most Lmax - 1), we can compute it directly.
        def nCr(n, r, mod):
            if r > n:
                return 0
            numerator = 1
            denominator = 1
            for i in range(1, r + 1):
                numerator = numerator * (n - r + i) % mod
                denominator = denominator * i % mod
            # Use Fermat's little theorem to compute modular inverse of denominator
            return numerator * pow(denominator, mod - 2, mod) % mod

        result = 0
        # Sum up for each chain length l (which corresponds to l distinct numbers)
        for l in range(1, Lmax + 1):
            count_chains = sum(dp[l][1:]) % mod
            # The number of ways to "stretch" a chain of l distinct numbers into an array of length n
            ways_to_place = nCr(n - 1, l - 1, mod)
            result = (result + count_chains * ways_to_place) % mod

        return result


Solution 2:

class Solution:
    MOD = 10**9 + 7

    def idealArrays(self, n: int, maxValue: int) -> int:
        # 1) Compute the max possible number of *distinct* values in an ideal array.
        maxChain = min(n, int(math.log2(maxValue)) + 1)

        # 2) DP layer: dp[v] = number of strictly‐increasing divisor-chains
        #    of the *current* length ending exactly at v.
        # Base (length = 1): there's exactly 1 way to have a chain of length 1 at v.
        dp = [1] * (maxValue + 1)

        # We'll record the total # of DISTINCT‐VALUE chains of each length:
        chains_count = [0] * (maxChain + 1)
        chains_count[1] = maxValue  # length1: each v=1..maxValue

        # Build up chains of length 2..maxChain
        for length in range(2, maxChain + 1):
            next_dp = [0] * (maxValue + 1)
            # Only step to strictly larger multiples k*u, k>=2
            for u in range(1, maxValue + 1):
                cnt = dp[u]
                if cnt:
                    v = u * 2
                    while v <= maxValue:
                        next_dp[v] = (next_dp[v] + cnt) % self.MOD
                        v += u
            dp = next_dp
            chains_count[length] = sum(dp[1:]) % self.MOD

        # 3) Precompute factorials & inverses up to n for fast C(n-1, k-1).
        fact = [1] * (n + 1)
        invfact = [1] * (n + 1)
        for i in range(1, n + 1):
            fact[i] = fact[i-1] * i % self.MOD
        invfact[n] = pow(fact[n], self.MOD - 2, self.MOD)
        for i in range(n, 0, -1):
            invfact[i-1] = invfact[i] * i % self.MOD

        def comb(a: int, b: int) -> int:
            if b < 0 or b > a: 
                return 0
            return fact[a] * invfact[b] % self.MOD * invfact[a-b] % self.MOD

        # 4) Sum over chain‐lengths: stretch each DISTINCT-value chain of length L
        #    into an array of length n by choosing (L-1) jumps in the (n-1) gaps:
        #    C(n-1, L-1) ways.
        result = 0
        for L in range(1, maxChain + 1):
            countChains = chains_count[L]
            waysToStretch = comb(n-1, L-1)
            result = (result + countChains * waysToStretch) % self.MOD

        return result
