889. Construct Binary Tree from Preorder and Postorder Traversal
Solved
Medium
Topics
Companies
Given two integer arrays, preorder and postorder where preorder is the preorder traversal of a binary tree of distinct values and postorder is the postorder traversal of the same tree, reconstruct and return the binary tree.

If there exist multiple answers, you can return any of them.

 

Example 1:


Input: preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]
Output: [1,2,3,4,5,6,7]
Example 2:

Input: preorder = [1], postorder = [1]
Output: [1]
 

Constraints:

1 <= preorder.length <= 30
1 <= preorder[i] <= preorder.length
All the values of preorder are unique.
postorder.length == preorder.length
1 <= postorder[i] <= postorder.length
All the values of postorder are unique.
It is guaranteed that preorder and postorder are the preorder traversal and postorder traversal of the same binary tree.


Solution 1:

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        n = len(preorder)
        
        def build_tree(pre_start, pre_end, post_start):
            if pre_start > pre_end:
                return None
            
            # Create the root node from the current preorder element.
            root = TreeNode(preorder[pre_start])
            # If this is a leaf node, return it.
            if pre_start == pre_end:
                return root
            
            # The left subtree's root is at preorder[pre_start + 1].
            # Find that value in the postorder array to determine the size of the left subtree.
            j = post_start
            while postorder[j] != preorder[pre_start + 1]:
                j += 1
            
            # Number of nodes in left subtree is: (j - post_start + 1)
            left_size = j - post_start + 1
            
            # Build the left subtree and right subtree recursively.
            root.left = build_tree(pre_start + 1, pre_start + left_size, post_start)
            root.right = build_tree(pre_start + left_size + 1, pre_end, j + 1)
            
            return root
        
        return build_tree(0, n - 1, 0)


Solution 2:

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        # Create a hash map to quickly find the index of values in postorder
        postorder_index = {val: idx for idx, val in enumerate(postorder)}
        
        def build(pre_start, pre_end, post_start):
            if pre_start > pre_end:
                return None
            # Create root from current preorder element
            root = TreeNode(preorder[pre_start])
            if pre_start == pre_end:
                return root  # Leaf node
            
            # Find the left child in preorder and its position in postorder
            left_child_val = preorder[pre_start + 1]
            j = postorder_index[left_child_val]
            
            # Calculate the size of the left subtree
            left_size = j - post_start + 1
            
            # Recursively build left and right subtrees
            root.left = build(pre_start + 1, pre_start + left_size, post_start)
            root.right = build(pre_start + left_size + 1, pre_end, j + 1)
            
            return root
        
        return build(0, len(preorder) - 1, 0)