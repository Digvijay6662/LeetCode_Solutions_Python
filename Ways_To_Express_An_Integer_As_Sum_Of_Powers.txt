2787. Ways to Express an Integer as Sum of Powers
Medium
200
9
Companies
Given two positive integers n and x.

Return the number of ways n can be expressed as the sum of the xth power of unique positive integers, in other words, the number of sets of unique integers [n1, n2, ..., nk] where n = n1x + n2x + ... + nkx.

Since the result can be very large, return it modulo 109 + 7.

For example, if n = 160 and x = 3, one way to express n is n = 23 + 33 + 53.

 

Example 1:

Input: n = 10, x = 2
Output: 1
Explanation: We can express n as the following: n = 32 + 12 = 10.
It can be shown that it is the only way to express 10 as the sum of the 2nd power of unique integers.
Example 2:

Input: n = 4, x = 1
Output: 2
Explanation: We can express n in the following ways:
- n = 41 = 4.
- n = 31 + 11 = 4.
 

Constraints:

1 <= n <= 300
1 <= x <= 5


Solution 1:

class Solution:
    def numberOfWays(self, n: int, x: int) -> int:
        mod = 10 ** 9 + 7
        dp = [[-1] * (n + 1) for _ in range(n + 1)]

        def solve(r, c):
            if dp[r][c] != -1:
                return dp[r][c]

            val = pow(c, x)

            if r == val:
                return 1
            
            if r < val:
                return 0
            
            op1 = solve(r - val, c + 1)
            op2 = solve(r, c + 1)

            dp[r][c] = (op1 + op2)  % mod
            
            return dp[r][c]
        
        return solve(n, 1)
        

Solution 2:

class Solution:
    def numberOfWays(self, n: int, x: int) -> int:
        mod = 10**9 + 7
        # dp[s] = number of ways to form sum 's' using x-th powers of unique integers considered so far
        dp = [0] * (n + 1)
        dp[0] = 1  # one way to form sum 0: choose nothing

        curr = 1  # current base whose x-th power we consider (1^x, 2^x, ...)

        # Iterate over all bases while their x-th power does not exceed n
        while pow(curr, x) <= n:
            val = pow(curr, x)  # current item value in a subset-sum sense

            # 0/1 knapsack update: iterate backward to ensure each power is used at most once
            for i in range(n, val - 1, -1):
                # Either don't take 'val' (keep dp[i]) or take it (add dp[i - val])
                dp[i] = (dp[i] + dp[i - val]) % mod

            curr += 1  # move to the next base

        # Number of ways to form sum n using unique x-th powers
        return dp[n]

