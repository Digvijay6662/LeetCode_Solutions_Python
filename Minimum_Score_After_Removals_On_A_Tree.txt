2322. Minimum Score After Removals on a Tree
Solved
Hard
Topics
premium lock icon
Companies
Hint
There is an undirected connected tree with n nodes labeled from 0 to n - 1 and n - 1 edges.

You are given a 0-indexed integer array nums of length n where nums[i] represents the value of the ith node. You are also given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.

Remove two distinct edges of the tree to form three connected components. For a pair of removed edges, the following steps are defined:

Get the XOR of all the values of the nodes for each of the three components respectively.
The difference between the largest XOR value and the smallest XOR value is the score of the pair.
For example, say the three components have the node values: [4,5,7], [1,9], and [3,3,3]. The three XOR values are 4 ^ 5 ^ 7 = 6, 1 ^ 9 = 8, and 3 ^ 3 ^ 3 = 3. The largest XOR value is 8 and the smallest XOR value is 3. The score is then 8 - 3 = 5.
Return the minimum score of any possible pair of edge removals on the given tree.

 

Example 1:


Input: nums = [1,5,5,4,11], edges = [[0,1],[1,2],[1,3],[3,4]]
Output: 9
Explanation: The diagram above shows a way to make a pair of removals.
- The 1st component has nodes [1,3,4] with values [5,4,11]. Its XOR value is 5 ^ 4 ^ 11 = 10.
- The 2nd component has node [0] with value [1]. Its XOR value is 1 = 1.
- The 3rd component has node [2] with value [5]. Its XOR value is 5 = 5.
The score is the difference between the largest and smallest XOR value which is 10 - 1 = 9.
It can be shown that no other pair of removals will obtain a smaller score than 9.
Example 2:


Input: nums = [5,5,2,4,4,2], edges = [[0,1],[1,2],[5,2],[4,3],[1,3]]
Output: 0
Explanation: The diagram above shows a way to make a pair of removals.
- The 1st component has nodes [3,4] with values [4,4]. Its XOR value is 4 ^ 4 = 0.
- The 2nd component has nodes [1,0] with values [5,5]. Its XOR value is 5 ^ 5 = 0.
- The 3rd component has nodes [2,5] with values [2,2]. Its XOR value is 2 ^ 2 = 0.
The score is the difference between the largest and smallest XOR value which is 0 - 0 = 0.
We cannot obtain a smaller score than 0.
 

Constraints:

n == nums.length
3 <= n <= 1000
1 <= nums[i] <= 108
edges.length == n - 1
edges[i].length == 2
0 <= ai, bi < n
ai != bi
edges represents a valid tree.


Solution 1:

class Solution:
    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:
        n = len(nums)

        # Build adjacency list for the undirected tree
        graph = defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)

        # Prepare arrays for:
        #   subTreeXor[i] = XOR of all values in subtree rooted at i
        #   inTime[i], outTime[i] = discovery/finish times for ancestor checks
        subTreeXor = [0] * n
        inTime = [0] * n
        outTime = [0] * n
        timer = 0

        def dfs(node: int, parent: int) -> None:
            """
            Perform DFS to:
              1. Record inTime when we first visit 'node'.
              2. Initialize subTreeXor[node] with nums[node].
              3. Recurse to children, accumulate their subtree XORs.
              4. Record outTime when we finish processing 'node'.
            """
            nonlocal timer
            inTime[node] = timer
            timer += 1

            # Start this node's subtree XOR with its own value
            subTreeXor[node] = nums[node]

            # Visit all neighbors except the parent
            for nei in graph[node]:
                if nei == parent:
                    continue
                dfs(nei, node)
                # Merge child's XOR into current node's subtree XOR
                subTreeXor[node] ^= subTreeXor[nei]

            outTime[node] = timer
            timer += 1

        def isAncestor(u: int, v: int) -> bool:
            """
            Return True if 'u' is an ancestor of 'v' in the DFS tree,
            determined by entry/exit times.
            """
            return inTime[u] <= inTime[v] and outTime[u] >= outTime[v]

        # Run DFS from arbitrary root (0) to fill subTreeXor, inTime, outTime
        dfs(0, -1)

        totalXor = subTreeXor[0]      # XOR of all nodes
        result = float('inf')         # track the minimum score

        # Try removing two edges by picking nodes u,v (1 <= u < v < n)
        for u in range(1, n):
            for v in range(u + 1, n):
                if isAncestor(u, v):
                    # Edge above v is inside subtree of edge above u
                    xor1 = subTreeXor[v]
                    xor2 = subTreeXor[u] ^ subTreeXor[v]
                    xor3 = totalXor ^ xor1 ^ xor2
                elif isAncestor(v, u):
                    # Edge above u is inside subtree of edge above v
                    xor1 = subTreeXor[u]
                    xor2 = subTreeXor[v] ^ subTreeXor[u]
                    xor3 = totalXor ^ xor1 ^ xor2
                else:
                    # The two removed edges are in disjoint subtrees
                    xor1 = subTreeXor[u]
                    xor2 = subTreeXor[v]
                    xor3 = totalXor ^ xor1 ^ xor2

                # Compute this split's score and update the result
                current_score = max(xor1, xor2, xor3) - min(xor1, xor2, xor3)
                result = min(result, current_score)

        return result