3445. Maximum Difference Between Even and Odd Frequency II
Solved
Hard
Topics
premium lock icon
Companies
Hint
You are given a string s and an integer k. Your task is to find the maximum difference between the frequency of two characters, freq[a] - freq[b], in a substring subs of s, such that:

subs has a size of at least k.
Character a has an odd frequency in subs.
Character b has an even frequency in subs.
Return the maximum difference.

Note that subs can contain more than 2 distinct characters.

 

Example 1:

Input: s = "12233", k = 4

Output: -1

Explanation:

For the substring "12233", the frequency of '1' is 1 and the frequency of '3' is 2. The difference is 1 - 2 = -1.

Example 2:

Input: s = "1122211", k = 3

Output: 1

Explanation:

For the substring "11222", the frequency of '2' is 3 and the frequency of '1' is 2. The difference is 3 - 2 = 1.

Example 3:

Input: s = "110", k = 3

Output: -1

 

Constraints:

3 <= s.length <= 3 * 104
s consists only of digits '0' to '4'.
The input is generated that at least one substring has a character with an even frequency and a character with an odd frequency.
1 <= k <= s.length


Solution 1:

class Solution:
    def maxDifference(self, s: str, k: int) -> int:
        n = len(s)
        result = float('-inf')

        # State 0 (00): count_a is even, count_b is even
        # State 1 (01): count_a is even, count_b is odd
        # State 2 (10): count_a is odd, count_b is even
        # State 3 (11): count_a is odd, count_b is odd
        def getState(count_a, count_b):
            pa = count_a & 1   # 1 if odd, 0 if even
            pb = count_b & 1
            return (pa << 1) | pb   # or however you map your two bits
            
        # try every ordered pair of digits a ≠ b
        chars = ['0', '1', '2', '3', '4']
        
        # Iterate over all ordered pairs (a, b), a != b
        for a in chars:
            for b in chars:
                if a == b:
                    continue

                # states[x] = min( count_a - count_b ) for a prefix whose parity-state = x
                states = [float('inf')] * 4

                l = -1
                count_a = count_b = 0
                prev_a  = prev_b  = 0

                for r in range(n):
                    # extend right end
                    if s[r] == a: count_a += 1
                    if s[r] == b: count_b += 1

                    # try shrinking from the left while window size ≥ k
                    while r - l >= k and (count_a - prev_a) >= 1 and (count_b - prev_b) >= 2:
                        left_state = getState(prev_a, prev_b)
                        states[left_state] = min(states[left_state], prev_a - prev_b)
                        l += 1
                        if s[l] == a: prev_a += 1
                        if s[l] == b: prev_b += 1

                    # compute current right-state & look up the complementary left-state
                    right_state = getState(count_a, count_b)
                    need_left  = right_state ^ 2  # flip the a-parity bit
                    best_left  = states[need_left]

                    if best_left != float('inf'):
                        diff = (count_a - count_b) - best_left
                        result = max(result, diff)

        return result