2179. Count Good Triplets in an Array
Solved
Hard
Topics
Companies
Hint
You are given two 0-indexed arrays nums1 and nums2 of length n, both of which are permutations of [0, 1, ..., n - 1].

A good triplet is a set of 3 distinct values which are present in increasing order by position both in nums1 and nums2. In other words, if we consider pos1v as the index of the value v in nums1 and pos2v as the index of the value v in nums2, then a good triplet will be a set (x, y, z) where 0 <= x, y, z <= n - 1, such that pos1x < pos1y < pos1z and pos2x < pos2y < pos2z.

Return the total number of good triplets.

 

Example 1:

Input: nums1 = [2,0,1,3], nums2 = [0,1,2,3]
Output: 1
Explanation: 
There are 4 triplets (x,y,z) such that pos1x < pos1y < pos1z. They are (2,0,1), (2,0,3), (2,1,3), and (0,1,3). 
Out of those triplets, only the triplet (0,1,3) satisfies pos2x < pos2y < pos2z. Hence, there is only 1 good triplet.
Example 2:

Input: nums1 = [4,0,1,3,2], nums2 = [4,1,0,2,3]
Output: 4
Explanation: The 4 good triplets are (4,0,3), (4,0,2), (4,1,3), and (4,1,2).
 

Constraints:

n == nums1.length == nums2.length
3 <= n <= 105
0 <= nums1[i], nums2[i] <= n - 1
nums1 and nums2 are permutations of [0, 1, ..., n - 1].


Solution 1:

class SegmentTree:
    def __init__(self, n):
        self.tree = [0] * (4 * n)

    def buildTree(self, l, r, i, arr):
        if l == r:
            self.tree[i] = arr[l]
            return

        m = (l + r) // 2
        self.buildTree(l, m, 2 * i + 1, arr)
        self.buildTree(m + 1, r, 2 * i + 2, arr)

        self.tree[i] = self.tree[2 * i + 1] + self.tree[2 * i + 2]

    def update(self, l, r, i, idx, val):
        if idx < l or idx > r:
            return 
    
        if l == r:
            self.tree[i] = val
            return

        m = (l + r) // 2
        if idx <= m:
            self.update(l, m, 2 * i + 1, idx, val)
        else:
            self.update(m + 1, r, 2 * i + 2, idx, val)

        self.tree[i] = self.tree[2 * i + 1] + self.tree[2 * i + 2]

    def query(self, l, r, i, lo, hi):
        if lo > r or hi < l:
            return 0

        if l >= lo and r <= hi:
            return self.tree[i]

        m = (l + r) // 2
        left_sum = self.query(l, m, 2 * i + 1, lo, hi)
        right_sum = self.query(m + 1, r, 2 * i + 2, lo, hi)
        return left_sum + right_sum

class Solution:
    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)
        tree = SegmentTree(n)
        idx_map = {}

        for i, val in enumerate(nums2):
            idx_map[val] = i

        result = 0

        for i in range(n):
            idx = idx_map[nums1[i]]
            common_element_on_left = tree.query(0, n - 1, 0, 0, idx)
            uncommon_element_on_left = i - common_element_on_left
            element_on_right = n - 1 - idx
            common_element_on_right = element_on_right - uncommon_element_on_left
            result += common_element_on_left * common_element_on_right
            tree.update(0, n - 1, 0, idx, 1)

        return result


Solution 2:

class FenwickTree:
    def __init__(self, n: int):
        # Initialize a BIT with n elements (using 1-indexed internal array)
        self.n = n
        self.tree = [0] * (n + 1)
    
    def update(self, index: int, delta: int):
        # BIT is internally 1-indexed; thus, add 1 to the 0-indexed index.
        index += 1
        while index <= self.n:
            self.tree[index] += delta
            # Move to the next index responsible for this position.
            index += index & -index

    def query(self, index: int) -> int:
        # Query returns the prefix sum from index 0 to the given index.
        summ = 0
        index += 1
        while index > 0:
            summ += self.tree[index]
            index -= index & -index
        return summ

class Solution:
    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)
        # Initialize the BIT to track processed positions (initially all 0s)
        bit = FenwickTree(n)
        
        # Build a mapping from value to its index in nums2.
        idx_map = {num: i for i, num in enumerate(nums2)}
        
        result = 0
        
        # Process each element in nums1 (which gives the order for one permutation).
        for i, num in enumerate(nums1):
            # Get the position of the current number in nums2.
            idx = idx_map[num]
            
            # common_left represents how many numbers earlier in nums1 have also been seen 
            # to the left (i.e. with indices <= idx) in nums2.
            common_left = bit.query(idx)
            
            # The number of elements processed so far that are not in the left segment of nums2.
            # (i.e. the ones that are “uncommon” in terms of ordering).
            uncommon_left = i - common_left
            
            # In nums2, count how many items come after the current element.
            rhs_total = (n - 1 - idx)
            
            # Deduce how many of these right-side elements would maintain the desired order.
            common_right = rhs_total - uncommon_left
            
            # For each element as the middle element of a triplet, the number of good triplets 
            # contributed is the product of the count on the left and the count on the right.
            result += common_left * common_right
            
            # Mark the element (its index in nums2) as processed.
            bit.update(idx, 1)
        
        return result
