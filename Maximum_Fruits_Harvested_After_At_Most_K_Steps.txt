2106. Maximum Fruits Harvested After at Most K Steps
Solved
Hard
Topics
premium lock icon
Companies
Hint
Fruits are available at some positions on an infinite x-axis. You are given a 2D integer array fruits where fruits[i] = [positioni, amounti] depicts amounti fruits at the position positioni. fruits is already sorted by positioni in ascending order, and each positioni is unique.

You are also given an integer startPos and an integer k. Initially, you are at the position startPos. From any position, you can either walk to the left or right. It takes one step to move one unit on the x-axis, and you can walk at most k steps in total. For every position you reach, you harvest all the fruits at that position, and the fruits will disappear from that position.

Return the maximum total number of fruits you can harvest.

 

Example 1:


Input: fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4
Output: 9
Explanation: 
The optimal way is to:
- Move right to position 6 and harvest 3 fruits
- Move right to position 8 and harvest 6 fruits
You moved 3 steps and harvested 3 + 6 = 9 fruits in total.
Example 2:


Input: fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], startPos = 5, k = 4
Output: 14
Explanation: 
You can move at most k = 4 steps, so you cannot reach position 0 nor 10.
The optimal way is to:
- Harvest the 7 fruits at the starting position 5
- Move left to position 4 and harvest 1 fruit
- Move right to position 6 and harvest 2 fruits
- Move right to position 7 and harvest 4 fruits
You moved 1 + 3 = 4 steps and harvested 7 + 1 + 2 + 4 = 14 fruits in total.
Example 3:


Input: fruits = [[0,3],[6,4],[8,5]], startPos = 3, k = 2
Output: 0
Explanation:
You can move at most k = 2 steps and cannot reach any position with fruits.
 

Constraints:

1 <= fruits.length <= 105
fruits[i].length == 2
0 <= startPos, positioni <= 2 * 105
positioni-1 < positioni for any i > 0 (0-indexed)
1 <= amounti <= 104
0 <= k <= 2 * 105


Solution 1:

class Solution:
    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:
        # Number of fruit positions
        n = len(fruits)
        
        # prefix_sum[i] will hold total fruits from fruits[0] up to fruits[i]
        prefix_sum = [0] * n
        
        # Extract just the positions into a separate list for binary searches
        indices = [fruit[0] for fruit in fruits]

        # Build the prefix-sum array in one pass
        for i in range(n):
            # Add current amount to running total (or start fresh at i = 0)
            prefix_sum[i] = fruits[i][1] + (prefix_sum[i - 1] if i > 0 else 0)

        max_fruits = 0

        # We try all ways of splitting our k steps into:
        #   1) going left d steps, then right (k - 2*d) steps
        #   2) going right d steps, then left (k - 2*d) steps
        # d ranges from 0 up to k//2 (can't go left more than half your budget if you plan to return)
        for d in range(k // 2 + 1):
            # --- CASE 1: left first, then right ---
            # steps remaining for the rightward leg after going left d and returning to start
            remain = k - 2 * d

            # interval of reachable positions: [startPos - d, startPos + remain]
            left_bound  = startPos - d
            right_bound = startPos + remain

            # find first index >= left_bound
            left_idx = bisect_left(indices, left_bound)
            # find last index <= right_bound
            right_idx = bisect_right(indices, right_bound) - 1

            # if there's at least one valid fruit position in [left_bound, right_bound]
            if left_idx <= right_idx:
                # compute total fruits by subtracting prefix sums
                total = prefix_sum[right_idx] - (prefix_sum[left_idx - 1] if left_idx > 0 else 0)
                max_fruits = max(max_fruits, total)

            # --- CASE 2: right first, then left ---
            # steps remaining for the leftward leg after going right d and returning
            remain = k - 2 * d

            # interval of reachable positions: [startPos - remain, startPos + d]
            left_bound  = startPos - remain
            right_bound = startPos + d

            left_idx = bisect_left(indices, left_bound)
            right_idx = bisect_right(indices, right_bound) - 1

            if left_idx <= right_idx:
                total = prefix_sum[right_idx] - (prefix_sum[left_idx - 1] if left_idx > 0 else 0)
                max_fruits = max(max_fruits, total)

        return max_fruits


Solution 2:

class Solution:
    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:
        # Total number of fruit positions
        n = len(fruits)
        
        # Split the input into two parallel lists:
        # pos  = sorted list of fruit positions
        # amt  = corresponding amounts at each position
        pos = [f[0] for f in fruits]

        # Build a prefix‐sum array of the amounts so that
        # we can query the sum in any subarray in O(1)
        prefix = [0] * n
        prefix[0] = fruits[0][1]                   # base case for the first position
        for i in range(1, n):
            # cumulative sum up to index i
            prefix[i] = prefix[i - 1] + fruits[i][1]

        def range_sum(i: int, j: int) -> int:
            """
            Return the total fruits from index i to j inclusive.
            Uses the prefix‐sum array to compute in O(1).
            """
            if i == 0:
                return prefix[j]
            return prefix[j] - prefix[i - 1]

        ans = 0   # will hold the maximum fruits we can collect
        l = 0     # left boundary of our sliding window over indices [l..r]

        # Iterate over r, the right boundary of the window
        for r in range(n):
            # Shrink window from the left while it's not reachable within k steps
            while l <= r:
                # Distance from startPos to the leftmost fruit in window
                leftDist = max(0, startPos - pos[l])
                # Distance from startPos to the rightmost fruit in window
                rightDist = max(0, pos[r] - startPos)

                # Two possible routes to cover [pos[l], pos[r]]:
                #  1) Go left first (to pos[l]), return to start, then go right to pos[r]:
                #     cost = 2*leftDist + rightDist
                #  2) Go right first, return to start, then go left:
                #     cost = leftDist + 2*rightDist
                cost = min(2 * leftDist + rightDist,
                           leftDist + 2 * rightDist)

                # If this window is within our step budget, stop shrinking
                if cost <= k:
                    break

                # Otherwise, move l rightward to drop the leftmost position
                l += 1

            # After adjusting l, if [l..r] is valid, update the answer
            if l <= r:
                current_total = range_sum(l, r)
                ans = max(ans, current_total)

        return ans