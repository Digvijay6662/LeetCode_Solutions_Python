3363. Find the Maximum Number of Fruits Collected
Solved
Hard
Topics
premium lock icon
Companies
Hint
There is a game dungeon comprised of n x n rooms arranged in a grid.

You are given a 2D array fruits of size n x n, where fruits[i][j] represents the number of fruits in the room (i, j). Three children will play in the game dungeon, with initial positions at the corner rooms (0, 0), (0, n - 1), and (n - 1, 0).

The children will make exactly n - 1 moves according to the following rules to reach the room (n - 1, n - 1):

The child starting from (0, 0) must move from their current room (i, j) to one of the rooms (i + 1, j + 1), (i + 1, j), and (i, j + 1) if the target room exists.
The child starting from (0, n - 1) must move from their current room (i, j) to one of the rooms (i + 1, j - 1), (i + 1, j), and (i + 1, j + 1) if the target room exists.
The child starting from (n - 1, 0) must move from their current room (i, j) to one of the rooms (i - 1, j + 1), (i, j + 1), and (i + 1, j + 1) if the target room exists.
When a child enters a room, they will collect all the fruits there. If two or more children enter the same room, only one child will collect the fruits, and the room will be emptied after they leave.

Return the maximum number of fruits the children can collect from the dungeon.

 

Example 1:

Input: fruits = [[1,2,3,4],[5,6,8,7],[9,10,11,12],[13,14,15,16]]

Output: 100

Explanation:



In this example:

The 1st child (green) moves on the path (0,0) -> (1,1) -> (2,2) -> (3, 3).
The 2nd child (red) moves on the path (0,3) -> (1,2) -> (2,3) -> (3, 3).
The 3rd child (blue) moves on the path (3,0) -> (3,1) -> (3,2) -> (3, 3).
In total they collect 1 + 6 + 11 + 16 + 4 + 8 + 12 + 13 + 14 + 15 = 100 fruits.

Example 2:

Input: fruits = [[1,1],[1,1]]

Output: 4

Explanation:

In this example:

The 1st child moves on the path (0,0) -> (1,1).
The 2nd child moves on the path (0,1) -> (1,1).
The 3rd child moves on the path (1,0) -> (1,1).
In total they collect 1 + 1 + 1 + 1 = 4 fruits.

 

Constraints:

2 <= n == fruits.length == fruits[i].length <= 1000
0 <= fruits[i][j] <= 1000


Solution 1:

class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        size = len(fruits)
        
        # dpization table for children 2 and 3
        # dp[row][col] stores max fruits collectible starting from (row, col)
        # for the respective child function
        dp = [[-1] * size for _ in range(size)]
        
        def collect_main_diagonal() -> int:
            """
            Child 1 starts at (0, 0) and can only move down, right, or down-right.
            On any optimal path to (size-1, size-1) with exactly size-1 moves,
            the only way to use all moves is to step along the main diagonal.
            """
            diagonal_sum = 0
            for idx in range(size):
                diagonal_sum += fruits[idx][idx]
            return diagonal_sum
        
        def collect_from_top_right(row: int, col: int) -> int:
            """
            Child 2 starts at (0, size-1). 
            Allowed moves: down-left (row+1, col-1), down (row+1, col), down-right (row+1, col+1).
            Uses dp to avoid recomputing subproblems.
            """
            # check bounds
            if row < 0 or row >= size or col < 0 or col >= size:
                return 0
            
            # enforce that this child stays in the upper-right triangle (row < col)
            if row >= col:
                return 0
            
            # if reached bottom-right, no more fruits beyond this step
            if row == size - 1 and col == size - 1:
                return 0
            
            # return cached result if available
            if dp[row][col] != -1:
                return dp[row][col]
            
            # collect fruits at current room
            current = fruits[row][col]
            
            # explore all three legal moves
            down_left_sum   = current + collect_from_top_right(row + 1, col - 1)
            down_sum        = current + collect_from_top_right(row + 1, col)
            down_right_sum  = current + collect_from_top_right(row + 1, col + 1)
            
            # pick the best move
            best = max(down_left_sum, down_sum, down_right_sum)
            dp[row][col] = best
            return best
        
        def collect_from_bottom_left(row: int, col: int) -> int:
            """
            Child 3 starts at (size-1, 0).
            Allowed moves: up-right (row-1, col+1), right (row, col+1), down-right (row+1, col+1).
            Uses the same dp table (fresh region) to avoid redundant searches.
            """
            # check bounds
            if row < 0 or row >= size or col < 0 or col >= size:
                return 0
            
            # enforce that this child stays in the lower-left triangle (row > col)
            if row <= col:
                return 0
            
            # if reached bottom-right, no more fruits beyond this step
            if row == size - 1 and col == size - 1:
                return 0
            
            # return cached result if available
            if dp[row][col] != -1:
                return dp[row][col]
            
            current = fruits[row][col]
            
            # explore all three legal moves
            up_right_sum    = current + collect_from_bottom_left(row - 1, col + 1)
            right_sum       = current + collect_from_bottom_left(row, col + 1)
            down_right_sum  = current + collect_from_bottom_left(row + 1, col + 1)
            
            best = max(up_right_sum, right_sum, down_right_sum)
            dp[row][col] = best
            return best
        
        # compute total fruits for each child
        child1_total = collect_main_diagonal()               # along main diagonal
        child2_total = collect_from_top_right(0, size - 1)   # start at top-right
        child3_total = collect_from_bottom_left(size - 1, 0) # start at bottom-left
        
        return child1_total + child2_total + child3_total


Solution 2:

class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        # n is the dimension of the square dungeon
        n = len(fruits)
        
        # dp[r][c] will eventually hold the max fruits collectible
        # at position (r, c) for child 2 and child 3 calculations
        dp = [[-1] * n for _ in range(n)]
        
        def collect_first_child_diagonal() -> int:
            """
            Child 1 travels from (0,0) to (n-1,n-1) along the main diagonal.
            Since they must make exactly (n - 1) moves and can only
            move right, down, or down-right, the only valid path is the diagonal.
            """
            diagonal_sum = 0
            for index in range(n):
                diagonal_sum += fruits[index][index]  # pick fruit at (index, index)
            return diagonal_sum
        
        # Initialize dp:
        # - In the strict upper-left triangle (row < col and row+col < n-1)
        #   only child 1 passes, so child2/3 collect 0 there.
        # - In the strict lower-left triangle (row > col and row+col < n-1)
        #   likewise only child 1 passes, so set to 0.
        # - Otherwise (the “join” regions for child2 or child3), start with base fruits.
        for row in range(n):
            for col in range(n):
                if (row < col and row + col < n - 1) or \
                   (row > col and row + col < n - 1):
                    dp[row][col] = 0
                else:
                    dp[row][col] = fruits[row][col]
        
        # Total fruits collected by child 1
        first_child_total = collect_first_child_diagonal()
        
        # ------------------------------------------------------------------------------
        # Compute dp entries for Child 2 (starting at (0, n-1))
        # Allowed moves: down-left, down, down-right.
        # We iterate by increasing rows; for each row, valid cols are (row+1 .. n-1).
        for row in range(1, n):
            for col in range(row + 1, n):
                # from (row-1, col+1) => down-left relative to parent
                down_left = dp[row - 1][col + 1] if col + 1 < n else 0
                # from (row-1, col)   => down
                down      = dp[row - 1][col]
                # from (row-1, col-1) => down-right
                down_right= dp[row - 1][col - 1]
                
                # add the best predecessor sum
                dp[row][col] += max(down_left, down, down_right)
        
        # ------------------------------------------------------------------------------
        # Compute dp entries for Child 3 (starting at (n-1, 0))
        # Allowed moves: up-right, right, down-right.
        # We iterate by increasing cols; for each col, valid rows are (col+1 .. n-1).
        for col in range(1, n):
            for row in range(col + 1, n):
                # from (row+1, col-1) => up-right relative to parent
                up_right   = dp[row + 1][col - 1] if row + 1 < n else 0
                # from (row,   col-1) => right
                right      = dp[row][col - 1]
                # from (row-1, col-1) => down-right
                down_right = dp[row - 1][col - 1]
                
                dp[row][col] += max(up_right, right, down_right)
        
        # After filling dp, the endpoints for children 2 and 3 are:
        # Child 2 ends at (n-2, n-1)
        # Child 3 ends at (n-1, n-2)
        second_child_total = dp[n - 2][n - 1]
        third_child_total  = dp[n - 1][n - 2]
        
        # Sum of all fruits collected by the three children
        return first_child_total + second_child_total + third_child_total