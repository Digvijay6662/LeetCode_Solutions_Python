689. Maximum Sum of 3 Non-Overlapping Subarrays
Solved
Hard
Topics
Companies
Given an integer array nums and an integer k, find three non-overlapping subarrays of length k with maximum sum and return them.

Return the result as a list of indices representing the starting position of each interval (0-indexed). If there are multiple answers, return the lexicographically smallest one.

 

Example 1:

Input: nums = [1,2,1,2,6,7,5,1], k = 2
Output: [0,3,5]
Explanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].
We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.
Example 2:

Input: nums = [1,2,1,2,1,2,1,2,1], k = 2
Output: [0,2,4]
 

Constraints:

1 <= nums.length <= 2 * 104
1 <= nums[i] < 216
1 <= k <= floor(nums.length / 3)


Solution 1:

class Solution:
    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        subarray_sum = []
        temp = 0

        for i in range(n):
            temp += nums[i]
            if i >= k - 1:
                subarray_sum.append(temp)
                temp -= nums[i - k + 1]    

        dp = [[-1] * 3 for _ in range(n)]
        def get_max_sum(i, count):
            if count == 3  or i > n - k:
                return 0

            if dp[i][count] != -1:
                return dp[i][count]

            pick = subarray_sum[i] + get_max_sum(i + k, count + 1)
            skip = get_max_sum(i + 1, count)

            dp[i][count] = max(pick, skip)   
            return dp[i][count]
            
        def get_indices():
            i = 0
            indices = []

            while i <= n - k and len(indices) < 3:
                pick = subarray_sum[i] + get_max_sum(i + k, len(indices) + 1)
                skip = get_max_sum(i + 1, len(indices))

                if pick >= skip:
                    indices.append(i)
                    i += k
                else:
                    i += 1

            return indices

        return get_indices()


Solution 2:

class Solution:
    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        subarray_sum = [0] * (n - k + 1)
        window_sum = 0

        for i in range(n):
            window_sum += nums[i]
            if i >= k - 1:
                subarray_sum[i - k + 1] = window_sum
                window_sum -= nums[i - k + 1]

        dp = [[0] * 4 for _ in range(len(subarray_sum) + 1)]

        for i in range(len(subarray_sum) - 1, -1, -1):
            for count in range(1, 4):
                pick = subarray_sum[i] + (dp[i + k][count - 1] if i + k < len(dp) else 0)
                skip = dp[i + 1][count] if i + 1 < len(dp) else 0
                dp[i][count] = max(pick, skip)


        result = []
        i, count = 0, 3
        while count > 0:
            pick = subarray_sum[i] + (dp[i + k][count - 1] if i + k < len(dp) else 0)
            skip = dp[i + 1][count] if i + 1 < len(dp) else 0

            if pick >= skip:
                result.append(i)
                i += k
                count -= 1
            else:
                i += 1

        return result


Solution 3:

class Solution:
    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        window_sums = [0] * (n - k + 1)
        left = [0] * (n - k + 1)
        right = [0] * (n - k + 1)
        
        # Step 1: Calculate sliding window sums
        curr_sum = sum(nums[:k])
        window_sums[0] = curr_sum
        for i in range(1, n - k + 1):
            curr_sum += nums[i + k - 1] - nums[i - 1]
            window_sums[i] = curr_sum
        
        # Step 2: Compute the best indices for the left subarray
        best_left = 0
        for i in range(n - k + 1):
            if window_sums[i] > window_sums[best_left]:
                best_left = i
            left[i] = best_left
        
        # Step 3: Compute the best indices for the right subarray
        best_right = n - k
        for i in range(n - k, -1, -1):
            if window_sums[i] >= window_sums[best_right]:
                best_right = i
            right[i] = best_right
        
        # Step 4: Find the best middle subarray index and combine
        max_sum = 0
        result = [-1, -1, -1]
        for mid in range(k, n - 2 * k + 1):
            l = left[mid - k]
            r = right[mid + k]
            total_sum = window_sums[l] + window_sums[mid] + window_sums[r]
            if total_sum > max_sum:
                max_sum = total_sum
                result = [l, mid, r]
                
        return result